

<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title>Charles Rymal by </title>
		<meta name="description" content="My Blog"/>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="theme-color" content="#157878">
		<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="/assets/css/style.css?v=">

		<script type="text/javascript"
		src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	</head>
	<body>
		<section class="page-header">
			<h1 class="project-name">Charles Rymal</h1>
			<h2 class="project-tagline">My Blog</h2>
			
			
		</section>

		<section class="main-content">
			<ul>
  <li>[[/CyclesInUndirectedGraph]]</li>
</ul>

<p>== Method For Finding Edge Subsets ==</p>

<p>This method should be applicable to four types of edge subsets:</p>
<ul>
  <li>cycles with repeated vertices</li>
  <li>cycles without repeated vertices</li>
  <li>paths with repeated vertices</li>
  <li>paths without repeated vertices</li>
</ul>

<p>The goal is to develop a method that we can prove finds all solutions and does so relatively efficiently.</p>

<p>Define a function $F$ of vertex or edge $x$ such that we can prove that $F$ will return all solutions (with no repeated solutions) that contain $x$ and no solutions that contain $y|y&lt;x$.
You can easily see that evaluating $F$ for each $x$ in the graph, we will obtain all solutions with no repeated solutions.</p>

<p>Clearly the challenge now is to find $F$ that satisfies the above.</p>

<p>Here is an attempt to write out these ideas using mathematical notation:</p>

<script type="math/tex; mode=display">% <![CDATA[
y \notin s, \forall s \in \textrm{F}(x), \forall y | y < x %]]></script>

<script type="math/tex; mode=display">\textrm{F}(x) \cap \textrm{F}(y) = \emptyset, x \neq y</script>

<script type="math/tex; mode=display">\bigcup_x \textrm{F}(x) = S</script>

<script type="math/tex; mode=display">% <![CDATA[
\textrm{F}(x) = \{ s | x \in s, y \notin s, y < x \} %]]></script>

<p>There is the question, should $F$ be a function of a vertex or an edge. I think that this does not matter. We must be able to say</p>

<script type="math/tex; mode=display">% <![CDATA[
S_{x <= a} \cup S_{x > a} = S, S_{x <= a} \cap S_{x > a} = \emptyset %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
S_{x <= a} = \{ s | x \in s, x <= a \} %]]></script>

<script type="math/tex; mode=display">% <![CDATA[
S_{x > a} = \{ s | x \in s, x > a, y \notin s, y <= a \} %]]></script>

<p>now consider $a = x_0$</p>

<script type="math/tex; mode=display">% <![CDATA[
S_{x <= x_0} = \{ s | x \in s, x <= x_0 \} = \{ s | x_0 \in s\} %]]></script>

<p>compare to</p>

<script type="math/tex; mode=display">% <![CDATA[
\textrm{F}(x_0) = \{ s | x_0 \in s, y \notin s, y < x_0 \} = \{ s | x_0 \in s \} %]]></script>

<p>so</p>

<script type="math/tex; mode=display">% <![CDATA[
S_{x <= x_0} = \textrm{F}(x_0) %]]></script>

<p>If we combine</p>

<script type="math/tex; mode=display">% <![CDATA[
\textrm{F}(x_0) \cup \textrm{F}(x_1) = \{ s | x_0 \in s \} \cup \{ s | x_1 \in s, y \notin s, y < x_1 \} = \{ s | x_0 \in s \} \cup \{ s | x_1 \in s, x_0 \notin s \} = \{ s | x \in s, x <= x_1 \} = S_{x <= x_1} %]]></script>

<p>The only requirement for using vertices or edges is that we can define the operators $\in$ and $\notin$ such that</p>

<script type="math/tex; mode=display">\begin{align}
\{s|x \in s\} \cup \{s|x \notin s\} = S\\\{s|x \in s\} \cap \{s|x \notin s\} = \emptyset
\end{align}</script>

<p>And I see no reason that we cannot do this for both vertices and edges, even though the solutions are fundamentally subsets of edges.</p>

<p>=== Depth First Search ===</p>

<p>Here we define a function that will serve as a recursive component of $F$ using a depth-first-search algorithm.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function g(v)
  for each edge e adjacent to v
    if the stack contains e then continue
    push e onto to stack

    if the stack is a valid solution
      save the stack as a solution

    if we should descend
      g(vertex opposite v in e)

    pop e from the stack
</code></pre>
</div>



			<footer class="site-footer">
				
				<span class="site-footer-credits">This page was generated by <a href="https://jekyllrb.com/">jekyll</a>.</span>
			</footer>
		</section>

		
	</body>
</html>

